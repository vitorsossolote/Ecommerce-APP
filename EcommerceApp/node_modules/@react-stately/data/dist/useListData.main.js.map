{"mappings":"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","sources":["packages/@react-stately/data/src/useListData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, Selection} from '@react-types/shared';\nimport {useMemo, useState} from 'react';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id ?? item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  toIndex -= indices.filter(index => index < toIndex).length;\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n"],"names":[],"version":3,"file":"useListData.main.js.map"}