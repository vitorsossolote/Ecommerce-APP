{"mappings":"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","sources":["packages/@react-stately/data/src/useAsyncList.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, LoadingState, Selection, SortDescriptor} from '@react-types/shared';\nimport {useEffect, useReducer, useRef} from 'react';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<AsyncListState<T, C>, [Action<T, C>]>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  let didDispatchInitialFetch = useRef(false);\n  useEffect(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({type: 'loading'}, load);\n      didDispatchInitialFetch.current = true;\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n"],"names":[],"version":3,"file":"useAsyncList.main.js.map"}