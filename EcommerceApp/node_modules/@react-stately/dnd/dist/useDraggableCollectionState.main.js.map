{"mappings":";;;;;;;;AAAA;;;;;;;;;;CAUC;AA+CM,SAAS,0CAA4B,KAAsC;IAChF,IAAI,YACF,QAAQ,cACR,UAAU,cACV,UAAU,oBACV,gBAAgB,eAChB,WAAW,cACX,UAAU,aACV,SAAS,WACT,OAAO,4BACP,wBAAwB,EACzB,GAAG;IACJ,IAAI,GAAG,YAAY,GAAG,CAAA,GAAA,qBAAO,EAAE;IAC/B,IAAI,eAAe,CAAA,GAAA,mBAAK,EAAE,IAAI;IAC9B,IAAI,aAAa,CAAA,GAAA,mBAAK,EAAE;IACxB,IAAI,UAAU,CAAC;QACb,mFAAmF;QACnF,qFAAqF;QACrF,uDAAuD;QACvD,IAAI,OAAO,IAAI,IACb,iBAAiB,UAAU,CAAC,OACxB,IAAI,IAAI;eAAI,iBAAiB,YAAY;SAAC,CAAC,MAAM,CAAC,CAAA,MAAO,CAAC,CAAC,WAAW,OAAO,CAAC,SAC9E,EAAE;QAGR,KAAK,GAAG,CAAC;QACT,OAAO;IACT;IAEA,OAAO;oBACL;0BACA;QACA,IAAI,cAAa;YACf,OAAO,WAAW,OAAO;QAC3B;QACA,IAAI,gBAAe;YACjB,OAAO,aAAa,OAAO;QAC7B;QACA,YAAW,GAAG;YACZ,OAAO,aAAa,OAAO,CAAC,GAAG,CAAC;QAClC;QACA,gBAAgB;QAChB,UAAS,GAAG;YACV,OAAO,SAAS,QAAQ;QAC1B;oBACA;iBACA;kCACA;QACA,WAAU,GAAG,EAAE,KAAK;YAClB,IAAI,OAAO,QAAQ;YACnB,aAAa,OAAO,GAAG;YACvB,WAAW,OAAO,GAAG;YACrB,iBAAiB,UAAU,CAAC;YAC5B,YAAY;YACZ,IAAI,OAAO,gBAAgB,YACzB,YAAY;gBACV,GAAG,KAAK;sBACR;YACF;QAEJ;QACA,UAAS,KAAK;YACZ,IAAI,OAAO,eAAe,YACxB,WAAW;gBACT,GAAG,KAAK;gBACR,MAAM,aAAa,OAAO;YAC5B;QAEJ;QACA,SAAQ,KAAK;YACX,IAAI,cACF,UAAU,EACX,GAAG;YAEJ,IAAI,OAAO,cAAc,YACvB,UAAU;gBACR,GAAG,KAAK;gBACR,MAAM,aAAa,OAAO;4BAC1B;YACF;YAGF,aAAa,OAAO,GAAG,IAAI;YAC3B,WAAW,OAAO,GAAG;YACrB,YAAY;QACd;IACF;AACF","sources":["packages/@react-stately/dnd/src/useDraggableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DraggableCollectionEndEvent, DraggableCollectionProps, DragItem, DragMoveEvent, DragPreviewRenderer, DragStartEvent, DropOperation, Key, Node, RefObject} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useRef, useState} from 'react';\n\nexport interface DraggableCollectionStateOptions extends DraggableCollectionProps {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** Whether the drag events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface DraggableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The key of the item that initiated a drag. */\n  draggedKey: Key | null,\n  /** The keys of the items that are currently being dragged. */\n  draggingKeys: Set<Key>,\n  /** Whether drag events are disabled. */\n  isDisabled?: boolean,\n  /** Returns whether the given key is currently being dragged. */\n  isDragging(key: Key): boolean,\n  /** Returns the keys of the items that will be dragged with the given key (e.g. selected items). */\n  getKeysForDrag(key: Key): Set<Key>,\n  /** Returns the items to drag for the given key. */\n  getItems(key: Key): DragItem[],\n  /** The ref of the element that will be rendered as the drag preview while dragging. */\n  preview?: RefObject<DragPreviewRenderer | null>,\n  /** Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. */\n  getAllowedDropOperations?: () => DropOperation[],\n  /** Begins a drag for the given key. This triggers the onDragStart event. */\n  startDrag(key: Key, event: DragStartEvent): void,\n  /** Triggers an onDragMove event. */\n  moveDrag(event: DragMoveEvent): void,\n  /** Ends the current drag, and emits an onDragEnd event. */\n  endDrag(event: DraggableCollectionEndEvent): void\n}\n\n/**\n * Manages state for a draggable collection.\n */\nexport function useDraggableCollectionState(props: DraggableCollectionStateOptions): DraggableCollectionState {\n  let {\n    getItems,\n    isDisabled,\n    collection,\n    selectionManager,\n    onDragStart,\n    onDragMove,\n    onDragEnd,\n    preview,\n    getAllowedDropOperations\n  } = props;\n  let [, setDragging] = useState(false);\n  let draggingKeys = useRef(new Set<Key>());\n  let draggedKey = useRef(null);\n  let getKeys = (key: Key) => {\n    // The clicked item is always added to the drag. If it is selected, then all of the\n    // other selected items are also dragged. If it is not selected, the only the clicked\n    // item is dragged. This matches native macOS behavior.\n    let keys = new Set(\n      selectionManager.isSelected(key)\n        ? new Set([...selectionManager.selectedKeys].filter(key => !!collection.getItem(key)))\n        : []\n    );\n\n    keys.add(key);\n    return keys;\n  };\n\n  return {\n    collection,\n    selectionManager,\n    get draggedKey() {\n      return draggedKey.current;\n    },\n    get draggingKeys() {\n      return draggingKeys.current;\n    },\n    isDragging(key) {\n      return draggingKeys.current.has(key);\n    },\n    getKeysForDrag: getKeys,\n    getItems(key) {\n      return getItems(getKeys(key));\n    },\n    isDisabled,\n    preview,\n    getAllowedDropOperations,\n    startDrag(key, event) {\n      let keys = getKeys(key);\n      draggingKeys.current = keys;\n      draggedKey.current = key;\n      selectionManager.setFocused(false);\n      setDragging(true);\n      if (typeof onDragStart === 'function') {\n        onDragStart({\n          ...event,\n          keys\n        });\n      }\n    },\n    moveDrag(event) {\n      if (typeof onDragMove === 'function') {\n        onDragMove({\n          ...event,\n          keys: draggingKeys.current\n        });\n      }\n    },\n    endDrag(event) {\n      let {\n        isInternal\n      } = event;\n\n      if (typeof onDragEnd === 'function') {\n        onDragEnd({\n          ...event,\n          keys: draggingKeys.current,\n          isInternal\n        });\n      }\n\n      draggingKeys.current = new Set();\n      draggedKey.current = null;\n      setDragging(false);\n    }\n  };\n}\n"],"names":[],"version":3,"file":"useDraggableCollectionState.main.js.map"}